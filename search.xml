<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[pdf.js的使用]]></title>
    <url>%2F2017%2F04%2F28%2Fpdf-js%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介最近接了一个新需求，会用到pdf.js，于是小白赶紧突击了一下，留下粗浅的笔记。PDF.js 是基于开放的 HTML5 及 JavaScript 技术实现的开源产品。简单说就是一个 PDF 解析器。首先附上pdf.js的github地址：https://github.com/mozilla/pdf.js官方网站：http://mozilla.github.io/pdf.js/然后咱们正式开始~~~~ 下载源码12$ git clone git://github.com/mozilla/pdf.js.git$ cd pdf.js 构建pdf.js这个项目是用gulp构建的，所以首先请确认已经安装gulp1$ (sudo) npm install gulp -g 然后安装项目所需的依赖1$ npm install 最后构建使用1$ gulp generic 使用粗略的看了github，然后准备跟着官网getting started，结果一脸萌比.jpg，好像并没有写什么哇，有兴趣的可以从examples开始研究~一切都还算顺利，直到我看到API…what?!无fuck说的小白＝＝后来我参考了几个示例，要么是hello world，要么是整个完整的最终版viewer。研究了一下自己的项目，感觉可以直接套用完成的viewer，哈哈哈哈哈，开心到花枝乱颤~~给大家看一下完整的viewer的效果，超级棒的！大家也可以在本地把pdf.js的项目挂起来，然后就可以看到辣！1$ gulp server 然后访问介个！http://localhost:8888/web/viewer.html其中generic/web/viewer.html主要是渲染pdf阅读器的样式，而generic/web/viewer.js则是指定打开的pdf文件。于是我们来看看viewer.js默认打开指定的文件可以通过file形参来动态指定打开的PDF文件在页面中可以用iframe把viewer.html嵌进去，就得到我们想要的样子了12&lt;iframe src="./generic/web/viewer.html" frameborder="0" width="100%" height="100%"&gt;&lt;/iframe&gt;// 相对路径的写法需参考自己的文件目录 然后我们指定一个file形参，就可以打开我们想开的PDF文件辣！12&lt;iframe src="./generic/web/viewer.html？file=./test.pdf" frameborder="0" width="100%" height="100%"&gt;&lt;/iframe&gt;// 相对路径的写法需参考自己的文件目录 大概酱紫！但是在我的实际项目中请求的file路径确是酱紫的！需要根据不同的参数，来选择展示不同的pdf文件，涉及到传参的问题了，仔细观察上面这段url地址会发现，在file请求参数中的值为一个url地址，而这个url地址又追加了自己的请求参数，这就导致一个url地址中出现2个”?”，导致浏览器不能正常解析这段url！一种解决思路是：我们可以把file形参的值，先编码，然后再解码来解决这个问题！所以用到了encodeURIComponent()函数来进行编码，如下：123456&lt;iframe id="viewer" frameborder="0" width="100%" height="100%"&gt;&lt;/iframe&gt;&lt;script type="text/javascript"&gt; var url = encodeURIComponent('/fop/convert/preview?cid=' + cid + '&amp;preview_format=pdf'); $('#viewer').attr('src', "./generic/web/viewer.html？file=" + url);&lt;/script&gt;// 请自己引用jquery 既然有编码，那么就一定要有解码来解析他，不过这个工作generic/web/viewer.js已经替我们做过了就这样实现了我的需求辣！ 参考除此之外，我们也可以从后台获取PDF的数据流，然后通过pdf.js来渲染。pdf.js渲染PDF文件的流程：Fetch pdf (url / buffer) ——&gt; canvas ——&gt; 渲染如果要深入pdf的渲染，需要去研究pdf.js源代码。pdf.js可通过pdf文件的地址或pdf数据流获取pdf，具体实现是调用接口函数 PDFJs.getDoc(url/buffer)将pdf载入html，通过canvas处理, 然后渲染pdf文件。详细问题大家可以参考：PDF.JS初级使用pdf.js文件流方式实现在线展示pdf文件pdf.js 写在最后明天就是五一小长假辣！抑制不住放假的喜悦哈哈哈！明天一早和男盆友赶早班飞机去北海涠洲岛，希望能enjoy呀！回来以后争取出个攻略哈哈哈！最后推荐大家可以去东极岛，虽然去年去的那几天天气炒鸡不好，但是感觉是个民风淳朴风景漂亮的小岛，炒鸡棒哒！放假嗨皮~~]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于dva-cli和antd的项目实践]]></title>
    <url>%2F2017%2F04%2F21%2F%E5%9F%BA%E4%BA%8Edva-cli%E5%92%8Cantd%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[背景最近这段时间都不是很忙，于是就抽空研究了一下dva，以前接触过react，做过一个问卷的小项目，代码在这里，在对react有一点了解的情况下，决定开始直接进攻dva，先去看了一些相关文档和介绍，对此有一个简略的笔记，现在我准备开始做一个小项目，目标就是实现基础的CRUD吧。 安装和初始化项目安装12$ (sudo) npm install dva-cli -g$ dva -v // 查看dva版本 创建应用新目录中进行初始化12$ dva new project$ cd project 已有目录中进行初始化123$ mkdir project$ cd project$ dva init 配置antd12$ npm install antd --save$ npm install babel-plugin-import --save-dev babel-plugin-import 用户按需引入antd的js和css文件。同时使用antd，dva时，通常需要配置额外的babel plugin，修改.roadhogrc，在extraBabelPlugins里加上：1["import", &#123;"libraryName": "antd", "style": "css"&#125;] 自动生成手脚架代码1234$ dva g route router_name // 生成路由$ dva g model model_name // 生成Model$ dva g component component_name //生成Component$ dva g component component_name --no-css //生成Component但是不生成css文件 项目构建文件目录修改后的文件目录 布局新建routes/MainContainer.js123456789101112131415161718192021222324252627282930import React, &#123;Component, PropTypes&#125; from 'react';import &#123;Layout&#125; from 'antd';import &#123; connect &#125; from 'dva';const &#123;Header, Content, Footer, Sider&#125; = Layout;function MainContainer(&#123;children, location, dispatch&#125;) &#123; return ( &lt;Layout&gt; &lt;Sider style=&#123;&#123;overflow: 'auto', background: '#fff'&#125;&#125;&gt; &lt;/Sider&gt; &lt;Layout&gt; &lt;Header style=&#123;&#123;background: '#fff', padding: 0&#125;&#125; /&gt; &lt;Content&gt; &#123;children&#125; &lt;/Content&gt; &lt;Footer style=&#123;&#123;textAlign: 'center'&#125;&#125;&gt; copyrigth ©2017 Created by Mogu &lt;/Footer&gt; &lt;/Layout&gt; &lt;/Layout&gt; );&#125;MainContainer.propTypes = &#123; location: PropTypes.object, dispatch: PropTypes.func&#125;;// 建立数据关联关系export default connect()(MainContainer); 新建IndexPage，并引入MainContainer.js1234567891011121314151617181920212223242526import React from 'react';import &#123; connect &#125; from 'dva';import styles from './IndexPage.css';import MainContainer from '../MainContainer';function IndexPage(&#123;location&#125;) &#123; return ( &lt;MainContainer location=&#123;location&#125;&gt; &lt;div className=&#123;styles.normal&#125;&gt; &lt;h1 className=&#123;styles.title&#125;&gt;Yay! Welcome to dva!&lt;/h1&gt; &lt;div className=&#123;styles.welcome&#125; /&gt; &lt;ul className=&#123;styles.list&#125;&gt; &lt;li&gt;To get started, edit &lt;code&gt;src/index.js&lt;/code&gt; and save to reload.&lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/dvajs/dva-docs/blob/master/v1/en-us/getting-started.md"&gt;Getting Started&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/MainContainer&gt; );&#125;IndexPage.propTypes = &#123;&#125;;export default connect()(IndexPage); 菜单栏新建components/Menus/Menus.jsx12345678910111213141516171819202122232425262728293031323334353637import React, &#123;Component, PropTypes&#125; from 'react';import &#123;Menu, Icon&#125; from 'antd';import &#123;Link&#125; from 'dva/router';const SubMenu = Menu.SubMenu;function Menus(&#123;&#125;) &#123; const menuProps = &#123;&#125;; return ( &lt;Menu mode="inline" &#123;...menuProps&#125; selectedKeys=&#123;[location.pathname]&#125;&gt; &lt;Menu.Item key="/"&gt; &lt;Icon type="home" /&gt;Home &lt;/Menu.Item&gt; &lt;SubMenu key="1" title=&#123;&lt;span&gt;&lt;Icon type="team" /&gt;User&lt;/span&gt;&#125;&gt; &lt;Menu.Item key="/users"&gt; UserList &lt;/Menu.Item&gt; &lt;Menu.Item key="/a"&gt; A菜单 &lt;/Menu.Item&gt; &lt;/SubMenu&gt; &lt;SubMenu key="2" title=&#123;&lt;span&gt;&lt;Icon type="setting" /&gt;Other&lt;/span&gt;&#125;&gt; &lt;Menu.Item key="/b"&gt; B菜单 &lt;/Menu.Item&gt; &lt;Menu.Item key="/c"&gt; C菜单 &lt;/Menu.Item&gt; &lt;/SubMenu&gt; &lt;/Menu&gt; );&#125;Menus.propTypes = &#123;&#125;export default Menus; 修改MainContainer.js，引入Menu.jsx12345678910......import Menus from '../components/Menus/Menus.jsx';function MainContainer(&#123;children, location, dispatch&#125;) &#123; return ( &lt;Layout&gt; &lt;Sider style=&#123;&#123;overflow: 'auto', background: '#fff'&#125;&#125;&gt; &lt;Menus &#123;...menuProps&#125;/&gt; &lt;/Sider&gt;...... 路由配置大致意思就是1.默认的IndexPage页面显示默认的内容。2.点击左侧菜单栏，右侧内容会局部刷新。 利用MainContainer.js中的children属性替换右侧显示内容修改route.js，配置对应路由12345678910111213141516171819202122232425import React from 'react';import &#123; Router, Route &#125; from 'dva/router';import IndexPage from './routes/IndexPage';import Users from "./routes/Users";import A from './routes/A";import B from './routes/B";import C from './routes/C";import D from './routes/D";function RouterConfig(&#123; history &#125;) &#123; return ( &lt;Router history=&#123;history&#125;&gt; &lt;Route path="/" component=&#123;IndexPage&#125; /&gt; &lt;Route path="/users" component=&#123;Users&#125; /&gt; &lt;Route path="/a" component=&#123;A&#125; /&gt; &lt;Route path="/b" component=&#123;B&#125; /&gt; &lt;Route path="/c" component=&#123;C&#125; /&gt; &lt;Route path="*" component=&#123;D&#125; /&gt; &lt;/Router&gt; );&#125;export default RouterConfig; 修改Menus.jsx，给左侧菜单加点击切换路由效果，也就是Link标签1234567891011121314151617181920212223242526 ...... return ( &lt;Menu mode="inline" &#123;...menuProps&#125; selectedKeys=&#123;[location.pathname]&#125;&gt; &lt;Menu.Item key="/"&gt; &lt;Link to="/"&gt;&lt;Icon type="home" /&gt;Home&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;SubMenu key="1" title=&#123;&lt;span&gt;&lt;Icon type="team" /&gt;User&lt;/span&gt;&#125;&gt; &lt;Menu.Item key="/users"&gt; &lt;Link to="/users"&gt;UserList&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;Menu.Item key="/a"&gt; &lt;Link to="/a"&gt;A菜单&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;/SubMenu&gt; &lt;SubMenu key="2" title=&#123;&lt;span&gt;&lt;Icon type="setting" /&gt;Other&lt;/span&gt;&#125;&gt; &lt;Menu.Item key="/b"&gt; &lt;Link to="/b"&gt;B菜单&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;Menu.Item key="/c"&gt; &lt;Link to="/c"&gt;C菜单&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;/SubMenu&gt; &lt;/Menu&gt; );&#125; ...... 至此，大致的页面显示应该都有了，但是涉及到动态变化的操作都没有实现。首先我们新建一个model文件，执行dva g model nav，它会在models下建立一个nav.js,并注入到index.js。1app.model(require('./models/nav); 修改models/nav.js123456789101112131415export default &#123; namespace: 'nav', state: &#123; navOpenKeys: JSON.parse(localStorage.getItem(`navOpenKeys`)) || [] &#125;, subscriptions: &#123; &#125;, effexts: &#123;&#125;, reducers: &#123; handleNavOpenKeys(state, &#123;payload: navOpenKeys&#125;) &#123; return &#123;...state, ...navOpenKeys&#125;; &#125; &#125;&#125; 这是菜单栏的主要数据逻辑，然后将它和菜单栏关联起来。修改MainContainer.js123456789101112131415161718192021222324252627282930313233343536373839404142......function MainContainer(&#123;children, location, dispatch, app&#125;) &#123; const &#123;navOpenKeys&#125; = app.nav; const menuProps = &#123; location, navOpenKeys, changeOpenKeys(openKeys) &#123; localStorage.setItem(`navOpenKeys`, JSON.stringify(openKeys)); dispatch(&#123;type: 'nav/handleNavOpenKeys', payload: &#123;navOpenKeys: openKeys&#125;&#125;) &#125; &#125; return ( &lt;Layout&gt; &lt;Sider style=&#123;&#123;overflow: 'auto', background: '#fff'&#125;&#125;&gt; &lt;Menus &#123;...menuProps&#125;/&gt; &lt;/Sider&gt; &lt;Layout&gt; &lt;Header style=&#123;&#123;background: '#fff', padding: 0&#125;&#125; /&gt; &lt;Content&gt; &#123;children&#125; &lt;/Content&gt; &lt;Footer style=&#123;&#123;textAlign: 'center'&#125;&#125;&gt; copyrigth ©2017 Created by Mogu &lt;/Footer&gt; &lt;/Layout&gt; &lt;/Layout&gt; );&#125;MainContainer.propTypes = &#123; location: PropTypes.object, dispatch: PropTypes.func, app: PropTypes.object&#125;;// 指定订阅数据，关联了usersfunction mapStateToProps(app) &#123; return &#123;app&#125;;&#125;// 建立数据关联关系export default connect(mapStateToProps)(MainContainer); 修改Menus.jsx12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849......function Menus(&#123;location, navOpenKeys, changeOpenKeys&#125;) &#123; const levelMap = &#123;&#125;; const menuProps = &#123; openKeys: navOpenKeys, onOpenChange &#125; // 保持选中 function getAncestorKeys(key) &#123; const map = []; const getParent = (index)=&gt;&#123; const result = [String(levelMap[index])]; if (levelMap[result[0]]) &#123; result.unshift(getParent(result[0])[0]); &#125; return result; &#125; for(let index in levelMap) &#123; if (&#123;&#125;.hasOwnProperty.call(levelMap, index)) &#123; map[index] = getParent(index); &#125; &#125; return map[key] || []; &#125; function onOpenChange(openKeys) &#123; const latestOpenKey = openKeys.find(key =&gt; !(navOpenKeys.indexOf(key)&gt;-1)); const latestCloseKey = navOpenKeys.find(key =&gt; !(openKeys.indexOf(key)&gt;-1)); let nextOpenKeys = []; if (latestOpenKey) &#123; nextOpenKeys = getAncestorKeys(latestOpenKey).concat(latestOpenKey); &#125; if (latestCloseKey) &#123; nextOpenKeys = getAncestorKeys(latestCloseKey) &#125; changeOpenKeys(nextOpenKeys); &#125; return ( &lt;Menu mode="inline" &#123;...menuProps&#125; selectedKeys=&#123;[location.pathname]&#125;&gt;......Menus.propTypes = &#123; navOpenKeys: PropTypes.array, changeOpenKeys: PropTypes.func&#125;export default Menus; 至此，我们的关联就做好了，菜单栏会根据用户的点击事件动态改变。 面包屑新建components/breads/breads.jsx1234567891011import React from 'react';import &#123;Link&#125; from 'react-router';import &#123;Breadcrumb&#125; from 'antd';function Breads() &#123; return ( &lt;Breadcrumb separator="&gt;" /&gt; );&#125;export default Breads; 修改MainContainer.js，并引入breads.js12345import Breads from '../components/breads/breads.jsx';.......&lt;Header style=&#123;&#123;background: '#fff', padding: 0&#125;&#125; &gt; &lt;Breads /&gt;&lt;/Header&gt;]]></content>
      <tags>
        <tag>dva</tag>
        <tag>ant design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git操作笔记]]></title>
    <url>%2F2017%2F04%2F20%2Fgit%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[写在前面最近可能陆续会补一些以前学习时做的笔记吧，算是一个回顾，也是总结一下准备新的开始。毕竟！再不学习！！就要废了！！！ git操作我比较常用的一个工作流程大概是这样： 初始化一个git仓库12// creates a new Git repositorygit init 本地仓库修改提交添加至暂存区12// adds files from the working directory to the staging areagit add 12git add . // 添加所有改变文件，任何未改变文件都不会被包含git add index.html // 添加 index.html 查看状态12// inspects the contents of the working directory and staging areagit status 查看改动12// shows the difference between the working directory and the staging area git diff 提交12// permanently stores file changes from the staging area in the repositorygit commit 云端仓库A remote is a Git repository that lives outside your Git project folder. Remotes can live on the web, on a shared network or even in a separate folder on your local computer.云端建立分支1git remote add origin git@github.com:username/repository.git 同步云端仓库12// push a local branch to the origin remotegit push -u origin master 这个流程一般是我在本地建好仓库后同步至github时的操作。还有一个常用的流程是从github克隆代码，然后本地修改上传。 克隆一个git仓库12// Creates a local copy of a remotegit clone url 版本回退查看提交纪录12// shows a list of all previous comitsgit log 查看云端项目12// Lists a Git project's remotes.git remote -v 回退1234567// backtrack in Git:// Discards changes in the working directorygit checkout HEAD filename// Unstages file changes in the staging areagit reset HEAD filename// Can be used to reset to a previous commit in your commit history.git reset SHA git分支Git branching allows users to experiment with different versions of a project by checking out separate branches to work on.12// Lists all a Git project's branches.git branch 12// Creates a new branch.git branch branch_name 12// Used to switch from one branch to another.git checkout branch_name 12// Deletes the branch specified.git branch -d branch_name 12// Used to join file changes from one branch to another.git merge branch_name git协作流程The Git Collaborative Workflow are steps that enable smooth project development when multiple collaborators are working on the same Git project.The workflow for Git collaborations typically follows this order:1.Fetch and merge changes from the remote12// Fetches work from the remote into the local copy.git fetch 12// Merges origin/master into your local branch.git merge origin/master 2.Create a branch to work on a new project feature3.Develop the feature on your branch and commit your work4.Fetch and merge from the remote again (in case new commits were made while you were working)5.Push your branch up to the remote for review]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快下班辣！]]></title>
    <url>%2F2017%2F04%2F13%2F%E5%BF%AB%E4%B8%8B%E7%8F%AD%E8%BE%A3%EF%BC%81%2F</url>
    <content type="text"><![CDATA[马上就要下班辣，刚才看fancybox相关的东西看到了一个武汉程序猿的博客，翻了一下博客记录，看到他给女儿注册的域名，然后妻子在记录女儿的生活点滴，好温馨呀~~~~于是一时兴起就开始更博了！之前还想着给博客加访客记录，评论balabala的新功能，结果搭起来以后就懒得管了…最近都不是很忙，接了一个新任务，还没开始着手弄，感觉不是简单的差事呀。最近开始研究做饭了，每天晚上回家都自己做饭吃，好像做饭也不是很难嘛，感觉自己很快就能成为会做饭的人了哈哈哈。清明节和闺蜜一起去了南京，好久不见分外想念呀，真希望每年都能抽一个时间跟好盆友一起出去转转呀，还希望你一切都好喽，等有男盆友了四个人一起玩一起愉快的打麻将哈哈哈。五一打算和男盆友去北海，几经波折终于订好了住和行，希望能少点幺蛾子吧。昨天晚上莫名其妙的就冲男盆友发脾气了…默默在心里念一百遍都是我不好吧…最近因为接连出去玩，还有房租和毫无节制的买买买，资金都比较紧张，所以就节省一点喽，但是也改变不了每年要出去走一走的计划哈。马上回家辣！希望今天能把鱼块煎好！盐不要放太多！]]></content>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dva笔记（一）]]></title>
    <url>%2F2017%2F04%2F10%2Fdva%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基本概念数据流向user/browser –dispatch–&gt; action —-&gt; reducer —-&gt; state —-&gt; componentuser/browser –dispatch–&gt; action —-&gt; effect —-&gt; state —-&gt; component Models1.state 数据状态。2.actiondispatch函数调用一个action，从而改变对应的数据，action必须带有type属性指明具体的行为。3.dispatch触发action的函数。在dva中，connect Model的组件通过props可以访问到dispatch，可以调用Model中的Reducer或者Effects。1234dispatch(&#123; type: &apos;add&apos;, // 如果在model外调用，需要添加namespace payload: &#123;&#125; //需要传递的信息&#125;) 4.reducer一个纯函数，同样的输入必须获得同样的输出。5.effect副作用，异步操作。6.subscription订阅一个数据源，然后根据条件dispatch需要的action。7.router路由。8.router components路由组件。 API app = dva(opts)创建应用，返回dva实例。opts： history：指定给路由用的history，默认是hashHistory。 initialize：指定初始数据，优先级高于model中的state，默认是{}。 app.use(hooks)配置hooks或者注册插件。 app.model(model)注册model。model包含的5个属性： namespace：命名空间，在全局state上的属性，只能用字符串，不支持通过.的方式创建多层命名空间。 state：初始值。 reducers：用于处理同步操作。(state, action) =&gt; newState effects：用于处理异步操作和业务逻辑。由action触发，可以触发action，可以和服务器交互，可以获取全局state的数据。*(action, effects) =&gt; void[*(action, effects) =&gt; void, {type}]type类型有：takeEvery, takeLatest, throttle, watcher subscriptions：订阅数据源。({dispatch, history}, done) =&gt; unlistenFunction app.unmodel(namespace)取消model注册，清理reducers，effects和subsctiptions。如果要使用app.unmodel()，subscription必须返回unlisten方法，用于取消数据订阅。 app.router({history, app} =&gt; RouterConfig)注册路由表。 app.start(selector?)启动应用。]]></content>
      <tags>
        <tag>dva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setMonth() & setDate()]]></title>
    <url>%2F2017%2F04%2F05%2FsetMonth-setDate%2F</url>
    <content type="text"><![CDATA[setMonth()月份0-11，日期如果不标准会自动调，将3.31 设置日期到 4月，但4月只有30天，没有31号，所以溢出了，js会自动将月份设到调到5月31号。建议先将日期设置为比较小的日期，比如1号。 setDate()类似的，setDate时如果日期不标准js也会自动调整，如将4月30日设置为31日，但4月只有30天，所以会溢出一天，js会自动将日期设置往后调整对应的天数。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轮播图slider的实现]]></title>
    <url>%2F2017%2F03%2F31%2F%E8%BD%AE%E6%92%AD%E5%9B%BEslider%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[原理一系列的大小相等的图片平铺，利用CSS布局只显示一张图片，其余隐藏。通过计算偏移量利用定时器实现自动播放，或通过手动点击事件切换图片。codedemo DOM操作页面加载完获取元素，然后通过dom元素的事件绑定，实现左右点击和button点击切换图片。注意在切换到最边缘的图片时，进行判断，跳转至相应图片位置。 定时器，自动轮播setTimeout&amp;setInterval 事件运用JS动画函数递归无限滚动参考文章：手把手原生js轮播图]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关setTimeout和setInterval]]></title>
    <url>%2F2017%2F03%2F29%2F%E6%9C%89%E5%85%B3setTimeout%E5%92%8CsetInterval%2F</url>
    <content type="text"><![CDATA[基本用法1.setTimeout指定延迟后调用函数2.setInterval以指定周期调用函数setTimeout和setInterval，将指定的代码移出本次执行，等到下一轮事件轮询时，再检查是否到了指定的时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮事件轮询时重新判断。 JavaScript是运行在单线程的环境中，定时器仅仅是计划代码在未来的某个时间执行，而具体执行时机是不能保证的。 setTimeout1setTimeout(function() &#123;...&#125;, timer); 为了确保两次执行之间有固定的间隔，可以不用setInterval，而是每次执行结束后，使用setTimeout指定下一次执行的具体时间。 12setTimeout(someTask, 100);veryLongTask(); setTimeout指定100ms以后运行someTask，但是，如果后面的veryLongTask函数运行时间很长，过了100ms还没结束，那someTask就得等到veryLongTask运行结束才执行。 setInterval1setInterval(function() &#123;...&#125;, interval); setInterval并不能保证两个函数之间的调用的间隔一定是与interval相符合的时间，周期会受function执行时间影响。setInterval指定的是”开始执行之间的间隔“，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，setInterval指定每100ms执行一次，每次执行需要5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。 1234567setInterval(function () &#123; console.log(2);&#125;, 1000);(function () &#123; sleeping(3000);&#125;)(); setInterval要求每隔1s输出一个2，但是sleeping要3s才能完成，就会导致在sleeping完成以后连续输出两个2，然后开始每隔1s输出一个2。setInterval具有累积效应，如果某个操作特别耗时，超过了setInterval的时间间隔，排在后面的操作会被累积起来，然后在很短的时间内连续触发，可能会造成性能问题。 更多请参考：setTimeout 和setInterval 何时被调用执行你真的了解setTimeout 和setInterval 吗定时器-阮一峰]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现背景透明文字不透明]]></title>
    <url>%2F2017%2F03%2F27%2Fcss%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E6%96%87%E5%AD%97%E4%B8%8D%E9%80%8F%E6%98%8E%2F</url>
    <content type="text"><![CDATA[css3 rgba()rgba()就可以实现了，r代表红色red，g代表绿色green，b代表蓝色blue，a代表透明度alpha。但是IE9以下好像就不支持rgba（）函数了。 IE9以下采用了IE渐变滤镜1filter:progid:DXImageTransform.Microsoft.Gradient(startColorStr=#AARRGGBB,endColorStr=#AARRGGBB) startColorStr设置或检索色彩渐变的开始颜色和透明度，格式为#AARRGGBB,AA、RR、GG、BB为十六进制正整数，取值范围为00-FF，AA指定透明度，00是完全透明，FF是完全不透明。超出取值范围的值将被恢复为默认值。2位透明度的换算方法： x=alpha*255，讲计算的结果x转换成十六进制即可。js换算16进制方法：x.toString(16)举个栗子：0.25的透明度 12var a = 0.25*255 = 63.75 ~= 64a.toString(16) = 40 endColorStr设置或检索色彩渐变的结束颜色和透明度。 rgba()+filter 兼容 12background: rgba(0,0,0,0.5);filter:progid:DXImageTransform.Microsoft.Gradient(startColorStr=#7F000000,endColorStr=#7F000000) 可以使所有主流浏览器元素实现50%透明的黑色背景。 opacity+filter设置元素的不透明度，这种不透明属性会让子元素也跟着半透明（即背景文字都透明），所以一般用于调整图片或者模块的整体不透明度。12opacity: 0.5;filter: Alpha(opacity=50); //兼容IE9以下版本 在IE6、7、8中使用filter属性，设置子元素为相对定位，可以让父元素透明，子元素不透明。12&lt;!--只支持IE6、7、8--&gt;@media \0screen\,screen\9 &#123;...&#125; 更多请参考关于IE中CSS-filter滤镜小知识ie8-hack(兼容IE6/7/8)]]></content>
      <tags>
        <tag>css</tag>
        <tag>兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好久不更博了！]]></title>
    <url>%2F2017%2F03%2F24%2F%E5%A5%BD%E4%B9%85%E4%B8%8D%E6%9B%B4%E5%8D%9A%E4%BA%86%EF%BC%81%2F</url>
    <content type="text"><![CDATA[好久不更博了呢看了一下上次更新博客的时间是3月9日，距离现在已经快小半个月了呢，中间试图写过一篇博客，关于安装Linux系统的，后来因为迟迟没有安装成功，博客就没有下文了…公司的电脑上装了win10，自己想装一个Linux玩玩，然后遇到了一个现在我都没解决的问题，uefi模式下的安装问题，后来就不了了之了…现在也没心思去弄。没更博的这段时间，做了一些什么工作呢？想了想，大概就是视频播放？做了一半，遇到了超级多的问题，很多都没有找到解决方法，可能是我解决问题的思路不对？最后这个烂摊子被leader接过去了…后来就零零散散的做了一些小任务，改了一些小bug吧，比如avalon表单正则验证，最后我用修改源码的方案解决了我的问题，也不知道这样算不算偷懒呢。噢！对，中间还有一个定时器的问题，被大佬指导了，后来还找同事问了问，主要就是setTimeout和setInterval的差别吧。唉，今天心情好差…昨天写了一个静态页面，感觉比刚开始工作的时候熟悉了一丢丢，或者是因为这个页面比较简单吧，实在不想说是很大的进步。中午吃饭的时候同事问：你月光吗，有存钱的打算吗…我说攒钱出去玩呀，她说没有存钱买房的打算吗，我…好像并没有这样的打算，更倾向于今天想买什么，买的起就马上买了，想去哪里玩，就开始攒钱等着出去玩，并没有想过要留多少积蓄…妈妈老说要细水长流，也叮嘱我有工资了也要多少给自己留点积蓄，可是好像从小就没培养出这种消费习惯…唔，明天就周末啦，下周就清明了，一直在计划清明去哪里玩，五一去哪里玩，可是总是隐隐觉得会不成行，或者玩的不太开心…哎，工作以后能出去玩的时间就那么几个假期，各地还都是人山人海…之前想五一去一个地方，然后等到国庆的时候再攒一笔钱去东南亚国家玩玩或者去大西北转转，现在想想也不知何时才会成行…有很多很多的期待，却只有一点一点地行动。]]></content>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决ie6、ie7下float:right换行的问题]]></title>
    <url>%2F2017%2F03%2F09%2F%E8%A7%A3%E5%86%B3ie6%E3%80%81ie7%E4%B8%8Bfloat-right%E6%8D%A2%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[IE7总是可以给人惊喜html结构如下：1234&lt;div class="link-wrap"&gt; &lt;a id="forget-pwd" href="./plugins/shunde/forget_password.html"&gt;忘记密码&lt;/a&gt; &lt;a id="register" href="./plugins/shunde/register.html"&gt;申请注册&lt;/a&gt;&lt;/div&gt; css样式如下：123456789101112131415.link-wrap &#123; width: 240px; font-size: 14px; position: absolute; bottom: 25px;&#125;.link-wrap a &#123; text-decoration: underline; color: #4E8CB1;&#125;#register &#123; float: right;&#125; chrome及其它浏览器中的显示：IE7中的显示：在一行足以放下所有元素的情况下，float:right的元素在IE7中出现了换行的问题。 how to fix？ 我用了一个最简单的方法，css样式不变，只要把float的元素放到非float的前面即可。如下：1234&lt;div class="link-wrap"&gt; &lt;a id="register" href="./plugins/shunde/register.html"&gt;申请注册&lt;/a&gt; &lt;a id="forget-pwd" href="./plugins/shunde/forget_password.html"&gt;忘记密码&lt;/a&gt;&lt;/div&gt; 参考文章http://stackoverflow.com/questions/4797573/float-right-in-ie7-dropping-to-a-new-linehttp://w3help.org/zh-cn/causes/RM8005]]></content>
      <tags>
        <tag>css</tag>
        <tag>兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[seajs 遇到的问题]]></title>
    <url>%2F2017%2F03%2F06%2Fseajs-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[遇到的问题嗯，又遇到问题了，也不是第一次遇到这个问题了，之前都没意识到是哪里不对，就忽略了这个问题，现在第二次遇到就去查了一下，大概是这样，在源文件中一切正常，用grunt构建以后的文件会出现下图的报错，我想应该是seajs管理依赖出了点问题。我的文件路径大概是这样：1234567├──plugins/│ │──shunde/│ │ │──js/│ └── └──index.html├───statics/├───modules/└───config.js 我的配置文件是这样：1234567891011seajs.config(&#123; base: './js/', alias: &#123; 'Handlebars': '../../../statics/scripts/handlebars.min.js', 'config': '../../../config.js' &#125;, map: [ ['.js', '.js?v=@@version'] ] &#125;);seajs.use('./js/register'); 我的register.js文件中这样引入了util.js，报错的parseForm函数就定义在util.js文件中：1var util = require('../../../modules/base/util'); 报错的原因应该是util.js文件引入失败。 ID和路径匹配原则所谓ID和路径匹配原则是指，使用seajs.use或require进行引用的文件，如果是具名模块（即定义了ID的模块），会把ID和seajs.use的路径名进行匹配，如果一致，则正确执行模块返回结果。反之，则返回null。Sea.js 的模块启动接口秉承的是路径即 ID 的设计原则。seajs.use 的方法的第一个参数被规定为文件路径（而不是 ID），可以通过 alias 来帮助 ID 匹配上最终的路径。在进行路径解析的时候require(&#39;../../../modules/base/util&#39;)，首先判断seajs.config是否定义了该alias，如果存在则替换；在这之后再根据base，将id值解析为url；最后进行map解析。 解决方法 在alias中新增util的定义 修改配置文件 123456789101112seajs.config(&#123; base: "./js/", alias: &#123; "Handlebars": '../../../statics/scripts/handlebars.min.js', 'config': '../../../config', 'util': '../../../modules/base/util' &#125;, map: [ ['.js', '.js?v=@@version'] ]&#125;);seajs.use('./js/register'); 修改register.js文件 1var util = require('util'); 修改base路径 修改配置文件 123456789101112seajs.config(&#123; base: "../../modules", alias: &#123; "Handlebars": '../../../statics/scripts/handlebars.min.js', 'config': '../../../config', 'util': '../../../modules/base/util' &#125;, map: [ ['.js', '.js?v=@@version'] ]&#125;);seajs.use('./js/register'); 参考文章https://github.com/seajs/seajs/issues/930]]></content>
  </entry>
  <entry>
    <title><![CDATA[解决各种好慢噢]]></title>
    <url>%2F2017%2F03%2F02%2F%E8%A7%A3%E5%86%B3%E5%90%84%E7%A7%8D%E5%A5%BD%E6%85%A2%E5%99%A2%2F</url>
    <content type="text"><![CDATA[gem install 太慢最近遇到的一个报错：我想大概就是让我去装ruby和sass吧，google了一下，得到这样的解决方式http://stackoverflow.com/questions/20176410/how-to-resolve-you-need-to-have-ruby-and-sass-installed-and-in-your-path-for-th结果由于国内网络不好，所以gem安装完全没反应。所以在国内，我们要想使用gem来安装相关的包的话，如果使用gem源地址，一般情况下都会安装失败，所以，我们需要将其替换为淘宝的Ruby包的网址就可以了。123456$ gem sources --remove httpd://rubygems.org/$ gem sources -a https://ruby.taobao.org/$ gem sources -1*** CURRENT SOURCE *** https://ruby.taobao.org/ 然后就可以愉快的使用gem安装辣！ npm install 太慢这个问题在最开始写代码的时候很多人应该就都遇到了，我用过两种解决方法：使用cnpm替代官方的npm来使用，因此直接安装cnpm1$ (sudo) npm install －g cnpm 使用国内镜像1.通过config命令 12$ npm config set registery http://registery.cnpmjs.org$ npm info underscore //如果上面配置正确这个命令会有字符串response 2.命令行指定 1$ npm --registery http://registery.cnpmjs.org info underscore 3.编辑~/.npmrc加入下面内容 1$ registery = http://registery.cnpmjs.org 以上几种方法，个人偏爱直接使用cnpm install来安装，也有很多人推荐编辑~/.npmrc的方法，将配置写死，萝卜青菜各有所爱，好用最重要！ git clone 太慢1.git shallow clone git clone默认下载项目的完整历史版本，如果只需要最新版的代码， 并不关心之前的历史信息，可以使用git的浅复制功能：1$ git clone --depth=1 https://github.com/***/***.git --depth=1表示只下载最近一次的版本，之后如果想获取完整历史信息，可以使用下面的命令：1$ git fetch --unshallow 或者，如果只是想下载最新的代码看看，也可以直接从Github上下载打包好的ZIP文件，但是相对来说，浅复制更灵活。网上还提供了很多其他的方法，很多我都没有尝试过，就不卖弄辣，总之科学上网！]]></content>
  </entry>
  <entry>
    <title><![CDATA[有关css选择器]]></title>
    <url>%2F2017%2F02%2F28%2F%E6%9C%89%E5%85%B3css%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[最近好忙，赶需求赶需求，赶完一个又一个。css好渣，对现如今还在使用IE6的用户真是深恶痛绝，每次改兼容性就是小半天过去了。吐槽了这么久，来说一说前段时间调样式的时候犯的错吧，有关css选择器。 :first-child 选择器:first-child 选择器用于选取属于其父元素的首个子元素的指定选择器。123456p:first-child &#123; font-weight: bold; //将作为某元素第一个子元素的所有p设置为粗体&#125;li:first-child &#123; text-transform: uppercase; //将某个元素第一个子元素的所有li元素变成大写&#125; 最常见的误解是：认为p:first-child这样的选择器会选择p元素的第一个子元素此外，对于较早版本的IE浏览器，&lt;!DOCTYPE&gt;必须声明，:first-child才会生效。举个栗子：匹配作为任何元素的第一个子元素的p元素12345678910111213&lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; p:first-child &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;some text&lt;/p&gt; &lt;p&gt;some text&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 匹配所有p元素中的第一个元素12345678910111213&lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; p &gt; i:first-child &#123; font-weight:bold; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;some &lt;i&gt;text&lt;/i&gt;. some &lt;i&gt;text&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;some &lt;i&gt;text&lt;/i&gt;. some &lt;i&gt;text&lt;/i&gt;.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 匹配所有作为第一个子元素的p元素中所有的i元素12345678910111213&lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; p:first-child i &#123; color:blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;some &lt;i&gt;text&lt;/i&gt;. some &lt;i&gt;text&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;some &lt;i&gt;text&lt;/i&gt;. some &lt;i&gt;text&lt;/i&gt;.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始]]></title>
    <url>%2F2017%2F02%2F20%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[我说的都对？ 第一次写博客好紧张嘤嘤嘤，希望能坚持写点东西出来哇。 入职一个多月啦，不像在家学习的时候那样每天心情好就学一点，心情不好就不学，每天可能会有新的工作，也不一定会有心思去学工作以外的东西。 我说的都不对？ 粗算一下也学了小半年了，还有好多东西不会，哭泣脸]]></content>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
</search>